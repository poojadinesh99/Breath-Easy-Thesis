"""
Supabase service for storing analysis results and user data.
"""
import os
import logging
from typing import Dict, Any, Optional
from datetime import datetime
import uuid

from ..core.config import settings

logger = logging.getLogger(__name__)

class SupabaseService:
    """Service for interacting with Supabase database."""
    
    def __init__(self):
        self.client = None
        self.connected = False
        self._initialize_client()
    
    def _initialize_client(self):
        """Initialize Supabase client with error handling."""
        try:
            # Import here to avoid dependency issues if supabase is not installed
            from supabase import create_client, Client
            
            if settings.SUPABASE_URL and settings.SUPABASE_KEY:
                self.client: Client = create_client(
                    settings.SUPABASE_URL, 
                    settings.SUPABASE_KEY
                )
                self.connected = True
                logger.info("âœ“ Supabase client initialized successfully")
            else:
                missing = []
                if not settings.SUPABASE_URL:
                    missing.append("SUPABASE_URL")
                if not settings.SUPABASE_KEY:
                    missing.append("SUPABASE_KEY")
                logger.warning(f"âš ï¸ Supabase credentials not configured ({', '.join(missing)}) - running in offline mode")
                
        except ImportError:
            logger.warning("âš ï¸ Supabase library not installed - running in offline mode")
        except Exception as e:
            logger.error(f"âŒ Failed to initialize Supabase client: {e}")
    
    async def save_analysis_result(
        self, 
        analysis_result: Dict[str, Any],
        audio_metadata: Optional[Dict[str, Any]] = None,
        user_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Save analysis result to Supabase.
        
        Args:
            analysis_result: The analysis result from the ML model
            audio_metadata: Metadata about the audio file
            user_id: Optional user identifier
            
        Returns:
            Dict containing save status and record information
        """
        if not self.connected:
            status = self.get_connection_status()
            logger.info(f"ðŸ“´ Database offline - analysis not saved (connected={status['connected']}, has_credentials={status['has_credentials']}, url={status['url']})")
            return {"status": "offline", "saved": False}
        
        try:
            # Get current time in local timezone for proper display
            from datetime import datetime, timezone
            import pytz
            
            # Get local timezone (adjust this to your timezone if needed)
            local_tz = pytz.timezone('Europe/Berlin')  # Change to your timezone
            current_time = datetime.now(local_tz)
            
            # Prepare record matching your exact schema
            record = {
                # id: uuid - auto-generated by default gen_random_uuid()
                "user_id": user_id if user_id else None,  # uuid foreign key to auth.users(id), can be NULL
                "file_name": audio_metadata.get("file_path", "unknown.wav") if audio_metadata else "unknown.wav",
                "analysis_type": "unified",  # Must be 'unified' or 'speech' per CHECK constraint
                "predicted_label": analysis_result.get("label", "unknown"),
                "confidence": float(analysis_result.get("confidence", 0.0)),
                "created_at": current_time.isoformat(),  # Explicit timestamp in local timezone
                "extra": {  # jsonb field for additional data
                    "predictions": analysis_result.get("predictions", {}),
                    "source": analysis_result.get("source", "local"),
                    "processing_time": analysis_result.get("processing_time", 0.0),
                    "text_summary": analysis_result.get("text_summary", ""),
                    "transcription": analysis_result.get("transcription", ""),  # Add transcription to extra
                    "audio_metadata": audio_metadata or {},
                    "model_version": "1.0.0",
                    "feature_set": "eGeMAPSv02",
                    "task_type": audio_metadata.get("task_type", "breath") if audio_metadata else "breath",
                    "local_timestamp": current_time.strftime("%Y-%m-%d %H:%M:%S %Z")
                }
            }
            
            # Insert into analysis_history table
            result = self.client.table("analysis_history").insert(record).execute()
            
            if result.data:
                record_id = result.data[0]["id"]
                logger.info(f"âœ“ Analysis result saved to Supabase (ID: {record_id})")
                return {
                    "status": "success",
                    "saved": True,
                    "record_id": record_id,
                    "table": "analysis_history"
                }
            else:
                logger.error("âŒ Failed to save to Supabase - no data returned")
                return {"status": "error", "saved": False, "error": "No data returned"}
                
        except Exception as e:
            logger.error(f"âŒ Error saving to Supabase: {e}")
            return {"status": "error", "saved": False, "error": str(e)}
    
    async def get_user_history(
        self, 
        user_id: str, 
        limit: int = 10
    ) -> Dict[str, Any]:
        """
        Get analysis history for a user.
        
        Args:
            user_id: User identifier
            limit: Maximum number of records to return
            
        Returns:
            Dict containing user's analysis history
        """
        if not self.connected:
            return {"status": "offline", "data": []}
        
        try:
            result = self.client.table("analysis_history")\
                .select("*")\
                .eq("user_id", user_id)\
                .order("created_at", desc=True)\
                .limit(limit)\
                .execute()
            
            return {
                "status": "success",
                "data": result.data or [],
                "count": len(result.data) if result.data else 0
            }
            
        except Exception as e:
            logger.error(f"âŒ Error fetching user history: {e}")
            return {"status": "error", "data": [], "error": str(e)}
    
    async def create_alert_if_needed(
        self,
        analysis_result: Dict[str, Any],
        user_id: Optional[str] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Create an alert if the analysis result indicates a concerning pattern.
        
        Args:
            analysis_result: The analysis result from the ML model
            user_id: Optional user identifier
            
        Returns:
            Dict containing alert information if created, None otherwise
        """
        if not self.connected:
            logger.info("ðŸ“´ Database offline - alert not created")
            return None
        
        try:
            label = analysis_result.get("label", "")
            confidence = float(analysis_result.get("confidence", 0.0))
            
            # Determine if an alert should be created
            alert_type = None
            alert_message = None
            
            if label == "crackles" and confidence > 0.6:
                alert_type = "warning"
                alert_message = f"Crackling sounds detected with {confidence*100:.1f}% confidence. This may indicate lung congestion or fluid. Consider consulting a healthcare professional."
            elif label == "wheezing" and confidence > 0.6:
                alert_type = "respiratory" 
                alert_message = f"Wheezing detected with {confidence*100:.1f}% confidence. This may indicate airway narrowing. Please monitor your breathing."
            elif label == "abnormal" and confidence > 0.65:
                alert_type = "abnormal"
                alert_message = f"Abnormal breathing pattern detected with {confidence*100:.1f}% confidence. Please monitor symptoms and consult healthcare provider if concerned."
            elif confidence > 0.8 and label != "normal":
                # High confidence non-normal result
                alert_type = "critical"
                alert_message = f"High confidence {label} pattern detected ({confidence*100:.1f}%). Please consult a healthcare professional promptly."
            
            # Create alert if conditions are met
            if alert_type and alert_message:
                alert_record = {
                    "user_id": user_id,  # Can be None for general alerts
                    "alert_type": alert_type,
                    "message": alert_message,
                    "is_resolved": False
                }
                
                result = self.client.table("alerts").insert(alert_record).execute()
                
                if result.data:
                    alert_id = result.data[0]["id"]
                    logger.info(f"ðŸš¨ Alert created: {alert_type} (ID: {alert_id})")
                    return {
                        "status": "created",
                        "alert_id": alert_id,
                        "alert_type": alert_type,
                        "message": alert_message
                    }
                else:
                    logger.warning("âš ï¸ Alert creation returned no data")
                    return {"status": "failed", "error": "No data returned"}
            else:
                logger.info("âœ… No alert needed - results within normal parameters")
                return {"status": "no_alert_needed"}
                
        except Exception as e:
            logger.error(f"âŒ Failed to create alert: {e}")
            return {"status": "error", "error": str(e)}
    
    def get_connection_status(self) -> Dict[str, Any]:
        """Get the current connection status."""
        return {
            "connected": self.connected,
            "url": settings.SUPABASE_URL[:30] + "..." if settings.SUPABASE_URL else None,
            "has_credentials": bool(settings.SUPABASE_URL and settings.SUPABASE_KEY)
        }
